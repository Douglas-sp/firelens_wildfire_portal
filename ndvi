import streamlit as st
import ee
import pandas as pd
import datetime

# --- 1. Initialize GEE with Service Account ---
def initialize_ee():
    if not ee.data._credentials:
        try:
            # Pulling credentials from Streamlit Secrets
            gee_json = st.secrets["gee_service_account"]
            credentials = ee.ServiceAccountCredentials(
                gee_json['client_email'], 
                key_data=gee_json['private_key']
            )
            ee.Initialize(credentials)
        except Exception as e:
            st.error(f"GEE Initialization Failed: {e}")

# --- 2. Cloud Masking Function ---
def mask_s2_clouds(image):
    """
    Uses the QA60 band to mask out opaque and cirrus clouds.
    Scales the S2_SR data to real-world reflectance values.
    """
    qa = image.select('QA60')

    # Bits 10 and 11 are clouds and cirrus, respectively.
    cloud_bit_mask = 1 << 10
    cirrus_bit_mask = 1 << 11

    # Both flags must be zero (indicating clear sky)
    mask = qa.bitwiseAnd(cloud_bit_mask).eq(0).And(
           qa.bitwiseAnd(cirrus_bit_mask).eq(0))

    # Apply mask and scale from 0-10000 to 0-1
    return image.updateMask(mask).divide(10000)

# --- 3. The Weather-Resistant NDVI Fetcher ---
def get_live_ndvi(lat, lon, buffer_deg):
    initialize_ee()
    
    # Define AOI geometry
    point = ee.Geometry.Point([lon, lat]).buffer(buffer_deg * 111000)
    
    # Temporal Window: 60 days provides more "cloud-free" opportunities
    now = datetime.datetime.now()
    start_date = (now - datetime.timedelta(days=60)).strftime('%Y-%m-%d')
    end_date = now.strftime('%Y-%m-%d')
    
    # Load and process Sentinel-2 Surface Reflectance
    collection = (ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                  .filterBounds(point)
                  .filterDate(start_date, end_date)
                  .map(mask_s2_clouds)) # Apply cloud mask to every image
    
    # Create a Median Composite (The 'cleanest' possible view)
    composite = collection.median()
    
    # Calculate NDVI: (B8 - B4) / (B8 + B4)
    ndvi_image = composite.normalizedDifference(['B8', 'B4']).rename('NDVI')
    
    # Calculate the mean NDVI across the AOI
    stats = ndvi_image.reduceRegion(
        reducer=ee.Reducer.mean(),
        geometry=point,
        scale=20,  # 20m scale is efficient for AOI-wide averages
        maxPixels=1e9
    )
    
    result = stats.get('NDVI').getInfo()
    
    # If the area is 100% clouded for 60 days, result is None
    return result if result is not None else 0.3

# --- 4. Sidebar UI Implementation ---
st.sidebar.title("ðŸ›°ï¸ Satellite Sync")
st.sidebar.write("Using Sentinel-2 (10m Resolution)")

# Check if site_lat exists (assuming it's defined elsewhere in your main script)
if 'current_ndvi' not in st.session_state:
    st.session_state['current_ndvi'] = 0.25

if st.sidebar.button("Fetch Live AOI Greenness"):
    with st.spinner("Filtering clouds and calculating NDVI..."):
        try:
            # Note: site_lat, site_lon, and site_buffer must be defined 
            # in your main app logic before calling this.
            live_val = get_live_ndvi(site_lat, site_lon, site_buffer)
            st.session_state['current_ndvi'] = round(live_val, 3)
            st.sidebar.success(f"Verified NDVI: {st.session_state['current_ndvi']}")
        except Exception as e:
            st.sidebar.error("Cloud cover too high or API Timeout.")
            # Use a safe fallback based on the Albertine Rift's dry season baseline
            st.session_state['current_ndvi'] = 0.25

# Use the current_ndvi variable for your XGBoost model prediction
current_ndvi = st.session_state['current_ndvi']